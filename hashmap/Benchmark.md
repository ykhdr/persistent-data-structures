# Бенчмарки

Описание процесса запуска бенчмарков и результаты для HashMap

## Запуск

```shell
go test -bench=. -benchmem .
```

## Результаты

Результаты бенчмарков на следующих характеристиках:

```
goos: darwin
goarch: arm64
cpu: Apple M4 Pro
```

Справка

```
ns/op - время выполнения операции в наносекундах

B/op - количество выделенной памяти в байтах на операцию

allocs/op - количество аллокаций на операцию
```

---

## Build — построение структуры из N элементов

| Размер | Реализация   |       ns/op |          B/op | allocs/op | Сравнение с HashMap |
|--------|--------------|------------:|--------------:|----------:|:--------------------|
| 100    | **HashMap**  |      15,179 |        59,483 |       649 | —                   |
|        | NaiveHashMap |      72,242 |       153,859 |       484 | **4.8x медленнее**  |
|        | GoMap        |       702.7 |         2,344 |         3 | 22x быстрее         |
| 1,000  | **HashMap**  |     209,274 |       938,600 |     7,691 | —                   |
|        | NaiveHashMap |   6,562,977 |    15,030,779 |     5,203 | **31x медленнее**   |
|        | GoMap        |       6,988 |        36,944 |         5 | 30x быстрее         |
| 10,000 | **HashMap**  |   3,400,725 |    12,850,767 |    90,763 | —                   |
|        | NaiveHashMap | 801,751,750 | 1,543,202,536 |   198,822 | **236x медленнее**  |
|        | GoMap        |      90,018 |       295,556 |        33 | 38x быстрее         |

> **Вывод:** HashMap существенно быстрее NaiveHashMap на построении (особенно на больших размерах), но Go map на порядок
> быстрее и почти не аллоцирует — из-за отсутствия персистентности и структурного шаринга.

---

## Get — чтение по ключу (hit/miss)

#### Hit — ключ найден

| Размер | Реализация   | ns/op | Сравнение с HashMap |
|--------|--------------|------:|:--------------------|
| 100    | **HashMap**  | 17.01 | —                   |
|        | NaiveHashMap | 3.667 | **4.6x быстрее**    |
|        | GoMap        | 4.351 | 3.9x быстрее        |
| 1,000  | **HashMap**  | 24.73 | —                   |
|        | NaiveHashMap | 3.795 | **6.5x быстрее**    |
|        | GoMap        | 3.631 | **6.8x быстрее**    |
| 10,000 | **HashMap**  | 31.26 | —                   |
|        | NaiveHashMap | 4.761 | **6.6x быстрее**    |
|        | GoMap        | 4.762 | **6.6x быстрее**    |

> **Вывод:** На чтении HashMap заметно медленнее из-за навигации по структуре (HAMT/уровни), тогда как NaiveHashMap и Go
> map выигрывают за счет прямого доступа без персистентных накладных расходов.

### Miss — ключ не найден

| Размер | Реализация   | ns/op | Сравнение с HashMap |
|--------|--------------|------:|:--------------------|
| 100    | **HashMap**  | 16.75 | —                   |
|        | NaiveHashMap | 11.49 | 1.5x быстрее        |
|        | GoMap        | 9.581 | 1.7x быстрее        |
| 1,000  | **HashMap**  | 24.85 | —                   |
|        | NaiveHashMap | 3.992 | **6.2x быстрее**    |
|        | GoMap        | 4.164 | **6.0x быстрее**    |
| 10,000 | **HashMap**  | 23.22 | —                   |
|        | NaiveHashMap | 6.439 | **3.6x быстрее**    |
|        | GoMap        | 6.284 | **3.7x быстрее**    |

> **Вывод:** Miss по-прежнему дороже для HashMap из-за прохождения уровней структуры. При этом на маленьком размере
> разница меньше, а на больших размерах NaiveHashMap/GoMap значительно быстрее.

---

### SetUpdate — обновление существующего ключа (персистентно)

| Размер | Реализация   |   ns/op |    B/op | allocs/op | Сравнение с HashMap |
|--------|--------------|--------:|--------:|----------:|:--------------------|
| 100    | **HashMap**  |   149.7 |     651 |         6 | —                   |
|        | NaiveHashMap |   1,320 |   2,344 |         3 | **8.8x медленнее**  |
|        | GoMap        |   7.099 |       0 |         0 | 21x быстрее         |
| 1,000  | **HashMap**  |   228.9 |     992 |         7 | —                   |
|        | NaiveHashMap |  15,861 |  36,944 |         5 | **69x медленнее**   |
|        | GoMap        |   10.26 |       0 |         0 | 22x быстрее         |
| 10,000 | **HashMap**  |   542.1 |   1,324 |         8 | —                   |
|        | NaiveHashMap | 174,591 | 295,558 |        33 | **322x медленнее**  |
|        | GoMap        |   12.51 |       0 |         0 | 43x быстрее         |

> **Вывод:** Персистентное обновление у HashMap масштабируется хорошо: аллоцируется ограниченное число узлов.
> NaiveHashMap деградирует из-за копирования/перестроения, а Go map ожидаемо быстрее, потому что обновляет in-place без
> аллокаций.

---

## SetInsert — вставка нового ключа (персистентно)

| Размер | Реализация   |   ns/op |    B/op | allocs/op | Сравнение с HashMap |
|--------|--------------|--------:|--------:|----------:|:--------------------|
| 100    | **HashMap**  |   173.3 |     728 |         6 | —                   |
|        | NaiveHashMap |   1,300 |   2,344 |         3 | **7.5x медленнее**  |
|        | GoMap        |   8.086 |       0 |         0 | 21x быстрее         |
| 1,000  | **HashMap**  |   258.1 |   1,136 |         8 | —                   |
|        | NaiveHashMap |  15,603 |  36,944 |         5 | **60x медленнее**   |
|        | GoMap        |   9.957 |       0 |         0 | 26x быстрее         |
| 10,000 | **HashMap**  |   544.1 |   1,423 |         9 | —                   |
|        | NaiveHashMap | 173,734 | 295,557 |        33 | **319x медленнее**  |
|        | GoMap        |   13.65 |       0 |         0 | 40x быстрее         |

> **Вывод:** Вставка для HashMap близка по стоимости к update (похожий путь копирования узлов). NaiveHashMap резко
> проигрывает на больших размерах. Go map выигрывает за счет мутабельной модели и отсутствия аллокаций.

---

## Delete — удаление ключа (персистентно)

| Размер | Реализация   |   ns/op |    B/op | allocs/op | Сравнение с HashMap |
|--------|--------------|--------:|--------:|----------:|:--------------------|
| 100    | **HashMap**  |   176.2 |     733 |         6 | —                   |
|        | NaiveHashMap |   1,392 |   2,344 |         3 | **7.9x медленнее**  |
|        | GoMap        |   754.4 |   2,344 |         3 | **4.3x медленнее**  |
| 1,000  | **HashMap**  |   261.3 |   1,109 |         7 | —                   |
|        | NaiveHashMap |  16,010 |  36,944 |         5 | **61x медленнее**   |
|        | GoMap        |   7,410 |  36,944 |         5 | **28x медленнее**   |
| 10,000 | **HashMap**  |   542.0 |   1,408 |         8 | —                   |
|        | NaiveHashMap | 178,548 | 295,557 |        33 | **329x медленнее**  |
|        | GoMap        |  88,837 | 295,557 |        33 | **164x медленнее**  |

> **Вывод:** В этом сценарии HashMap выигрывает у Go map и NaiveHashMap, так как персистентная реализация платит только
> за копирование пути, а альтернативы в данном замере показывают высокую стоимость удаления.

---

## Iterate — итерация по всем элементам

| Размер | Реализация   |  ns/op | Сравнение с HashMap |
|--------|--------------|-------:|:--------------------|
| 100    | **HashMap**  |  258.0 | —                   |
|        | NaiveHashMap |  405.1 | 1.6x медленнее      |
|        | GoMap        |  441.5 | 1.7x медленнее      |
| 1,000  | **HashMap**  |  2,507 | —                   |
|        | NaiveHashMap |  5,428 | **2.2x медленнее**  |
|        | GoMap        |  5,238 | **2.1x медленнее**  |
| 10,000 | **HashMap**  | 29,274 | —                   |
|        | NaiveHashMap | 48,709 | 1.7x медленнее      |
|        | GoMap        | 48,190 | 1.6x медленнее      |

> **Вывод:** В этих измерениях HashMap быстрее на итерации, что указывает на эффективный обход структуры без
> дополнительных накладных расходов конкретных реализаций сравнения.

---

## Version Creation — создание множества версий

| Размер | Версий | Реализация   |       ns/op |        B/op | allocs/op | Сравнение с HashMap |
|--------|--------|--------------|------------:|------------:|----------:|:--------------------|
| 1,000  | 10     | **HashMap**  |       2,109 |       9,968 |        74 | —                   |
|        |        | NaiveHashMap |     158,499 |     370,005 |        70 | **75x медленнее**   |
|        |        | GoMapCopy    |     156,420 |     369,927 |        60 | **74x медленнее**   |
| 1,000  | 100    | **HashMap**  |      21,342 |      99,281 |       734 | —                   |
|        |        | NaiveHashMap |   1,545,903 |   3,700,060 |       702 | **72x медленнее**   |
|        |        | GoMapCopy    |   1,549,398 |   3,699,266 |       602 | **73x медленнее**   |
| 1,000  | 1,000  | **HashMap**  |     215,570 |     998,338 |     7,300 | —                   |
|        |        | NaiveHashMap |  15,557,969 |  37,000,797 |     7,024 | **72x медленнее**   |
|        |        | GoMapCopy    |  15,445,717 |  36,992,710 |     6,023 | **72x медленнее**   |
| 10,000 | 10     | **HashMap**  |       4,769 |      13,408 |        86 | —                   |
|        |        | NaiveHashMap |   2,074,092 |   2,956,203 |       353 | **435x медленнее**  |
|        |        | GoMapCopy    |   2,059,645 |   2,956,128 |       343 | **432x медленнее**  |
| 10,000 | 100    | **HashMap**  |      47,143 |     131,957 |       846 | —                   |
|        |        | NaiveHashMap |  20,274,817 |  29,562,029 |     3,535 | **430x медленнее**  |
|        |        | GoMapCopy    |  20,252,501 |  29,561,331 |     3,436 | **430x медленнее**  |
| 10,000 | 1,000  | **HashMap**  |     525,571 |   1,324,001 |     8,533 | —                   |
|        |        | NaiveHashMap | 200,740,325 | 295,620,220 |    35,349 | **382x медленнее**  |
|        |        | GoMapCopy    | 204,394,158 | 295,612,336 |    34,354 | **389x медленнее**  |

> **Вывод:** Structural sharing дает огромный выигрыш при создании версий: HashMap создает новые версии значительно
> быстрее и с существенно меньшими затратами памяти, чем полное копирование (NaiveHashMap/GoMapCopy). Особенно заметно на
> размере 10K.

---

## Mixed Operations — смешанные операции

| Реализация   |         ns/op |          B/op | allocs/op | Сравнение с HashMap                    |
|--------------|--------------:|--------------:|----------:|:---------------------------------------|
| **HashMap**  |     4,193,722 |    14,860,615 |   103,470 | —                                      |
| NaiveHashMap | 1,084,961,042 | 1,983,065,808 |   251,199 | **259x медленнее, 133x больше памяти** |
| GoMap        |       106,492 |       295,556 |        33 | 39x быстрее                            |

> **Вывод:** На смешанном сценарии HashMap многократно быстрее NaiveHashMap благодаря шарингу, но Go map остается
> существенно быстрее из-за мутабельных операций и низких аллокаций.

---

## Memory Allocation — аллокации при multipleSet

| Реализация   |     ns/op |      B/op | allocs/op | Сравнение с HashMap                        |
|--------------|----------:|----------:|----------:|:-------------------------------------------|
| **HashMap**  |     846.5 |     1,754 |        10 | —                                          |
| NaiveHashMap | 1,941,741 | 2,364,577 |       258 | **2,294x медленнее, 1,348x больше памяти** |
| GoMap        |     15.04 |         0 |         0 | 56x быстрее                                |

> **Вывод:** HashMap требует больше аллокаций, чем Go map, но на порядки экономичнее NaiveHashMap. Это ожидаемо:
> персистентность платит ограниченным копированием узлов, а наивная реализация копирует/пересоздает значительно больше
> данных.
