# Persistent Vector

Persistent Vector — это неизменяемая структура данных с эффективным доступом по индексу и модификацией. Реализована на основе 32-way Trie (дерево с ветвлением 32) с tail-оптимизацией.

## Ключевые характеристики

| Операция | Сложность           |
|----------|---------------------|
| Get(i) | O(log_32(n)) ≈ O(1) |
| Set(i, v) | O(log_32(n)) ≈ O(1) |
| Append(v) | O(1) |
| Pop() | O(1) |
| Len() | O(1)                |

Для миллиарда элементов глубина дерева не превышает 7 уровней -> сложность операций фактически константная.

## Алгоритмы

### Индексация (Get)

Индекс разбивается на 5-битные сегменты, каждый из которых определяет путь в дереве:

```
Индекс: 1000 (десятичное)
Бинарное: 0b1111101000

Разбиение по 5 бит (справа налево):
  01000 = 8   -> индекс в листе
  11111 = 31  -> индекс в родителе
  
Путь: root.children[31].values[8]
```

Для более глубоких деревьев:
```
shift = 10 (два уровня над листьями):
  Уровень 10: (index >> 10) & 31 -> children[...]
  Уровень 5:  (index >> 5) & 31  -> children[...]
  Уровень 0:  index & 31         -> values[...]
```

### Tail-оптимизация

Последние элементы хранятся в отдельном слайсе для ускорения Append:

```
До Append(X):
root: [дерево с элементами 0..999]
tail: [1000, 1001, 1002]  - 3 элемента, есть место для новых

После Append(X):
root: [не изменился]
tail: [1000, 1001, 1002, X]  - добавлен новый элемент
```

Когда tail заполняется (32 элемента максимум в ноду), он сбрасывается в дерево:

```
До Append(X) (tail полный):
root: [дерево]
tail: [32 элемента]

После Append(X):
root: [дерево + бывший tail как новый лист]
tail: [X]  - новый tail с одним элементом
```

### Path Copying (Structural Sharing)

При модификации копируется только путь от корня до изменяемого узла. 
Т.е. при модификации одного элемента создаётся новая версия вектора, но большая часть структуры данных разделяется между версиями

## Пример использования

```go
// Создание
v := persistent.NewVector[int]()

// Добавление элементов
v = v.Append(1).Append(2).Append(3)

// Доступ по индексу
val, ok := v.Get(1)  // val = 2, ok = true
val, ok := v.Get(10) // val = 0, ok = false

// Модификация (исходный массив не изменяется, создаётся новая версия)
v2 := v.Set(1, 100)

// Оригинал не изменился
val1, _ := v.Get(1)   // 2
val2, _ := v2.Get(1)  // 100

// Удаление с конца
v3, removed, ok := v.Pop()

// Итерирование по всем элементам
for i, val := range v.All() {
    fmt.Printf("[%d] = %d\n", i, val)
}
```

## Сравнение с альтернативами

| Подход | Get          | Set | Append | Память на Set        |
|--------|--------------|-----|-------|----------------------|
| Копирование массива | O(1)         | O(n) | O(n) | O(n)                 |
| Fat Node | O(1)         | O(1) | O(1) | O(1), но узел растёт |
| 32-way Trie | O(log_32(n)) | O(log_32(n)) | O(1) | O(log_32(n))         |


## Ссылки

- [Clojure Persistent Vectors pt.1](https://hypirion.com/musings/understanding-persistent-vector-pt-1)
- [Clojure Persistent Vectors pt.2](https://hypirion.com/musings/understanding-persistent-vector-pt-2)