# Бенчмарки

Описание процесса запуска бенчмарков и результаты

## Запуск

```shell
go test -bench=. -benchmem .
```

# Результаты

Результаты бенчмарков на следующих характеристиках:
```
goos: darwin
goarch: arm64
cpu: Apple M4 Pro
```

### Справка

`ns/op` - время выполнения операции в наносекундах

`B/op` - количество выделенной памяти в байтах на операцию

`allocs/op` - количество аллокаций на операцию


## Append — добавление элементов

| Размер | Реализация | ns/op | B/op | allocs/op | Сравнение с Vector |
|--------|------------|------:|-----:|----------:|:-------------------|
| 100 | **Vector** | 3,865 | 21,216 | 207 | — |
| | NaiveArray | 6,620 | 44,624 | 200 | 1.7x медленнее |
| | Slice | 249 | 2,040 | 8 | 15x быстрее |
| | SlicePrealloc | 97 | 896 | 1 | 40x быстрее |
| 1,000 | **Vector** | 38,945 | 214,723 | 2,063 | — |
| | NaiveArray | 429,848 | 4,297,970 | 2,000 | **11x медленнее** |
| | Slice | 2,210 | 25,208 | 12 | 18x быстрее |
| | SlicePrealloc | 877 | 8,192 | 1 | 44x быстрее |
| 10,000 | **Vector** | 421,257 | 2,297,103 | 20,905 | — |
| | NaiveArray | 30,308,731 | 428,763,772 | 20,048 | **72x медленнее** |
| | Slice | 26,499 | 357,628 | 19 | 16x быстрее |
| | SlicePrealloc | 6,861 | 81,920 | 1 | 61x быстрее |

> **Вывод:** При последовательном добавлении NaiveArray проигрывает из-за копирования всего массива на каждый Append. Vector значительно лучше, но обычный slice все равно быстрее за счет отсутствия персистентности.

---

## Get — чтение по индексу

| Размер | Реализация | ns/op | Сравнение |
|--------|------------|------:|:----------|
| 100 | **Vector** | 1.39 | — |
| | NaiveArray | 0.23 | 6x быстрее |
| | Slice | 0.22 | 6x быстрее |
| 1,000 | **Vector** | 1.34 | — |
| | NaiveArray | 0.23 | 6x быстрее |
| | Slice | 0.22 | 6x быстрее |
| 10,000 | **Vector** | 1.69 | — |
| | NaiveArray | 0.22 | 8x быстрее |
| | Slice | 0.22 | 8x быстрее |
| 100,000 | **Vector** | 2.09 | — |
| | NaiveArray | 0.23 | 9x быстрее |
| | Slice | 0.22 | 9x быстрее |

> **Вывод:** Vector медленнее на Get из-за навигации по дереву (O(log_32(n))), но разница всего 1-2 наносекунды — практически незаметно.

---

## Set — персистентное изменение элемента

| Размер | Реализация | ns/op | B/op | allocs/op | Сравнение с Vector |
|--------|------------|------:|-----:|----------:|:-------------------|
| 100 | **Vector** | 122 | 1,072 | 3 | — |
| | NaiveArray | 89 | 896 | 1 | 1.4x быстрее |
| | SliceCopy | 88 | 896 | 1 | 1.4x быстрее |
| 1,000 | **Vector** | 124 | 1,072 | 3 | — |
| | NaiveArray | 794 | 8,192 | 1 | **6x медленнее** |
| | SliceCopy | 791 | 8,192 | 1 | **6x медленнее** |
| 10,000 | **Vector** | 216 | 1,584 | 4 | — |
| | NaiveArray | 5,093 | 81,920 | 1 | **24x медленнее** |
| | SliceCopy | 4,836 | 81,920 | 1 | **22x медленнее** |
| 100,000 | **Vector** | 361 | 2,096 | 5 | — |
| | NaiveArray | 40,041 | 802,819 | 1 | **111x медленнее** |
| | SliceCopy | 41,269 | 802,819 | 1 | **114x медленнее** |

> **Вывод:** Vector в сотни раз быстрее других реализаций. При изменении копируется только путь (~log_32(n) узлов), а не весь массив. На 100K элементах Vector в **111 раз быстрее** и использует в **383 раза меньше памяти**.

---

## Pop — удаление с конца

| Размер | Реализация | ns/op | B/op | allocs/op | Сравнение с Vector |
|--------|------------|------:|-----:|----------:|:-------------------|
| 100 | **Vector** | 23 | 72 | 2 | — |
| | NaiveArray | 92 | 896 | 1 | **4x медленнее** |
| | SliceCopy | 90 | 896 | 1 | **4x медленнее** |
| 1,000 | **Vector** | 25 | 112 | 2 | — |
| | NaiveArray | 801 | 8,192 | 1 | **32x медленнее** |
| | SliceCopy | 800 | 8,192 | 1 | **32x медленнее** |
| 10,000 | **Vector** | 33 | 176 | 2 | — |
| | NaiveArray | 4,982 | 81,920 | 1 | **151x медленнее** |
| | SliceCopy | 4,924 | 81,920 | 1 | **149x медленнее** |

> **Вывод:** Vector выигрывает благодаря tail-оптимизации — Pop обычно работает только с tail без копирования.

---

## Iterate — итерация по всем элементам

| Размер | Реализация | ns/op | Сравнение с Vector |
|--------|------------|------:|:-------------------|
| 100 | **Vector** | 143 | — |
| | NaiveArray | 28 | 5x быстрее |
| | Slice | 28 | 5x быстрее |
| 1,000 | **Vector** | 1,395 | — |
| | NaiveArray | 234 | 6x быстрее |
| | Slice | 232 | 6x быстрее |
| 10,000 | **Vector** | 17,178 | — |
| | NaiveArray | 2,250 | 8x быстрее |
| | Slice | 2,251 | 8x быстрее |

> **Вывод:** Итерация по Vector медленнее из-за вызовов Get для каждого элемента. 

---

## Version Creation — создание множества версий

| Размер | Версий | Реализация | ns/op | B/op | Сравнение с Vector |
|--------|--------|------------|------:|-----:|:-------------------|
| 1,000 | 10 | **Vector** | 1,295 | 10,720 | — |
| | | NaiveArray | 8,226 | 82,161 | **6x медленнее** |
| 1,000 | 100 | **Vector** | 12,880 | 107,201 | — |
| | | NaiveArray | 82,132 | 821,609 | **6x медленнее** |
| 10,000 | 10 | **Vector** | 2,185 | 15,840 | — |
| | | NaiveArray | 65,202 | 819,448 | **30x медленнее** |
| 10,000 | 100 | **Vector** | 22,175 | 158,401 | — |
| | | NaiveArray | 652,576 | 8,194,485 | **29x медленнее, 52x больше памяти** |

> **Вывод:** Structural sharing дает огромный выигрыш при работе с версиями. 100 версий массива из 10K элементов: Vector — 155KB, NaiveArray — 8MB.

---

## Mixed Operations — смешанные операции

| Реализация | ns/op | B/op | allocs/op | Сравнение |
|------------|------:|-----:|----------:|:----------|
| **Vector** | 55,196 | 332,340 | 2,465 | — |
| NaiveArray | 570,698 | 5,530,374 | 2,300 | **10x медленнее, 17x больше памяти** |

---

## Memory Allocation — аллокации при Set

| Реализация | ns/op | B/op | allocs/op |
|------------|------:|-----:|----------:|
| **Vector** | 218 | 1,584 | 4 |
| NaiveArray | 5,383 | 81,920 | 1 |

> Vector: **25x быстрее**, **52x меньше памяти** на операцию Set для массива из 10,000 элементов.
