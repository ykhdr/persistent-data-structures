# Неизменяемые структуры данных (Persistent Data Structures)


## Цели и задачи

В рамках проекта требуется:

- реализовать набор persistent-структур данных;
- обеспечить единый и естественный API;
- использовать эффективные алгоритмы (быстрее и экономичнее, чем fat-node подход);
- поддержать вложенность структур и историю изменений.

---

## Язык и ограничения

- **Язык реализации**: Go
- Используются **generics**
- Не используются:
  - встроенные immutable/persistent коллекции
  - сторонние библиотеки с готовыми реализациями

---

## Реализуемые структуры данных

### 1. Persistent Vector (массив)

**Описание**

Persistent-аналог динамического массива с эффективным доступом по индексу.

**Реализация**

- Основан на **32-way trie (дерево с ветвлением 32)**
- Используется **tail-оптимизация** для быстрых операций добавления
- При изменении копируется **только путь от корня до изменённого узла** (path copying)

**Сложность операций**

| Операция | Сложность |
|--------|----------|
| Доступ по индексу | $O(\log_{32} n)$ |
| Обновление элемента | $O(\log_{32} n)$ |
| Добавление в конец | амортизированное $O(1)$ |

---

### 2. Persistent HashMap (ассоциативный массив)

**Описание**

Неизменяемый ассоциативный массив.

**Реализация**

- Основан на HAMT/CHAMP (Hash Array Mapped Trie / Compressed Hash-Array Mapped Prefix-tree)
- Доступ к подузлам через bitmap indexing (сжатое представление дочерних ссылок)
- При изменениях используется path copying: копируется только путь до изменённого узла, остальное разделяется между версиями

**Сложность операций**

| Операция | Сложность |
|--------|----------|
| Get | амортизированное $O(1)$ |
| Set (Put) | амортизированное $O(1)$ |
| Delete | амортизированное $O(1)$ |

---

### 3. Persistent Queue (очередь)

**Описание**

Неизменяемая очередь (FIFO).

**Реализация**

- Основана на двух persistent-стеках:
  - `front` — для извлечения (dequeue / peek)
  - `rear` — для добавления (enqueue)
- При опустевшем `front` выполняется ленивый разворот `rear -> front` (reverse)
- Используется structural sharing: стек — persistent связный список, `push`/`pop` создают новые версии без копирования всей структуры

**Сложность операций**

| Операция | Сложность |
|--------|----------|
| Enqueue | $O(1)$ |
| Dequeue | амортизированное $O(1)$, худший случай $O(n)$ |
| Peek | амортизированное $O(1)$, худший случай $O(n)$ |

---

## Общие архитектурные принципы

### Path Copying (вместо fat-node)

- История изменений **не хранится внутри узлов**
- При модификации копируется только путь от корня до изменённого элемента
- Неизменённые поддеревья **разделяются между версиями**

Преимущества:
- более быстрый доступ,
- меньше накладных расходов на память,
- упрощённая логика чтения.

---

## Единый API

Все структуры данных:

- являются **неизменяемыми**;
- каждая операция возвращает **новую версию структуры**;
- используют схожие принципы API (Get / Set / Put / Delete и т.д.).


## Дополнительные требования

### 1. Вложенность структур с сохранением типизации

Поддерживается хранение persistent-структур внутри других persistent-структур с использованием generics.

Пример:
```go
HashMap[string, *Vector[Order]]
Vector[HashMap[string, Vector[int]]]
```
### 2. Универсальный undo / redo механизм

Реализуется механизм истории версий:
* каждая версия структуры хранит ссылку на корень;
* undo / redo — это переключение между сохранёнными версиями.

### 3. Более эффективное представление, чем fat-node

* применяется path copying;
