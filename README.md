# Неизменяемые структуры данных (Persistent Data Structures)


## Цели и задачи

В рамках проекта требуется:

- реализовать набор persistent-структур данных;
- обеспечить единый и естественный API;
- использовать эффективные алгоритмы (быстрее и экономичнее, чем fat-node подход);
- поддержать вложенность структур и историю изменений.

---

## Язык и ограничения

- **Язык реализации**: Go  
- Используются **generics**
- Не используются:
  - встроенные immutable/persistent коллекции
  - сторонние библиотеки с готовыми реализациями

---

## Реализуемые структуры данных

### 1. Persistent Vector (массив)

**Описание**

Persistent-аналог динамического массива с эффективным доступом по индексу и поддержкой версий.

**Реализация**

- Основан на **32-way trie (дерево с ветвлением 32)**  
- Используется **tail-оптимизация** для быстрых операций добавления
- При изменении копируется **только путь от корня до изменённого узла** (path copying)

**Сложность операций**

| Операция | Сложность |
|--------|----------|
| Доступ по индексу | $O(\log_{32} n)$ |
| Обновление элемента | $O(\log_{32} n)$ |
| Добавление в конец | амортизированное $O(1)$ |

---

### 2. Persistent HashMap (ассоциативный массив)

**Описание**

Неизменяемый ассоциативный массив с поддержкой версий.

**Реализация**

- ???

**Сложность операций**

| Операция | Сложность |
|--------|----------|
| Get / Put / Delete | $O(1)$ |

---

### 3. Persistent Queue (дополнительно)

**Описание**

Очередь с поддержкой версий.

**Реализация**

- Основана на двух persistent-стеках:
  - `front` — для извлечения
  - `rear` — для добавления
- При необходимости используется **ленивый разворот** стека

---

## Общие архитектурные принципы

### Path Copying (вместо fat-node)

- История изменений **не хранится внутри узлов**
- При модификации копируется только путь от корня до изменённого элемента
- Неизменённые поддеревья **разделяются между версиями**

Преимущества:
- более быстрый доступ,
- меньше накладных расходов на память,
- упрощённая логика чтения.

---

## Единый API

Все структуры данных:

- являются **неизменяемыми**;
- каждая операция возвращает **новую версию структуры**;
- используют схожие принципы API (Get / Set / Put / Delete и т.д.).


## Дополнительные требования

### 1. Вложенность структур с сохранением типизации

Поддерживается хранение persistent-структур внутри других persistent-структур с использованием generics.

Пример:
```go
HashMap[string, *Vector[Order]]
Vector[HashMap[string, Vector[int]]]
```
### 2. Универсальный undo / redo механизм

Реализуется механизм истории версий:
* каждая версия структуры хранит ссылку на корень;
* undo / redo — это переключение между сохранёнными версиями;
* поддерживается **каскадность**:
* вложенные структуры корректно разделяют версии.

### 3. Более эффективное представление, чем fat-node

* применяется path copying;
