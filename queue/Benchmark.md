# Бенчмарки

Описание процесса запуска бенчмарков и результаты для Queue

## Запуск

```shell
go test -bench=. -benchmem .
```

## Результаты

Результаты бенчмарков на следующих характеристиках:

```
goos: darwin
goarch: arm64
cpu: Apple M4 Pro
```

Справка

```
ns/op - время выполнения операции в наносекундах

B/op - количество выделенной памяти в байтах на операцию

allocs/op - количество аллокаций на операцию
```

---

## Enqueue — добавление в конец очереди

| Размер | Реализация |      ns/op | Сравнение с Queue  |
|--------|------------|-----------:|:-------------------|
| 100    | **Queue**  |      2,896 | —                  |
|        | NaiveQueue |      6,412 | **2.2x медленнее** |
| 1,000  | **Queue**  |     29,339 | —                  |
|        | NaiveQueue |    483,774 | **16x медленнее**  |
| 10,000 | **Queue**  |    314,988 | —                  |
|        | NaiveQueue | 31,906,225 | **101x медленнее** |

> **Вывод:** Enqueue у Queue масштабируется существенно лучше, чем у NaiveQueue.
> Это связано с тем, что Queue добавляет элементы в хвостовую персистентную структуру без пересборки всей очереди,
> тогда как NaiveQueue вынуждена копировать или пересоздавать значительную часть структуры.
> На больших размерах преимущество Queue становится на порядки.

---

## Dequeue — удаление с начала очереди

| Размер | Реализация |  ns/op | Сравнение с Queue |
|--------|------------|-------:|:------------------|
| 100    | **Queue**  | 0.9888 | —                 |
|        | NaiveQueue | 0.3721 | **2.7x быстрее**  |
| 1,000  | **Queue**  | 0.9952 | —                 |
|        | NaiveQueue | 0.3531 | **2.8x быстрее**  |
| 10,000 | **Queue**  | 0.9946 | —                 |
|        | NaiveQueue | 0.3878 | **2.6x быстрее**  |

> **Вывод:** Dequeue у обеих реализаций работает за константное время.
> NaiveQueue показывает меньшую константу, так как операция представляет собой простой доступ к head без
> дополнительных инвариантов. Queue платит небольшой фиксированной ценой за поддержку двух персистентных структур
> и сохранение корректности версий.

---

## Peek — чтение первого элемента без удаления

| Размер  | Реализация |     ns/op | Сравнение с NaiveQueue |
|---------|------------|----------:|:-----------------------|
| 100     | **Queue**  |     2,857 | —                      |
|         | NaiveQueue |    0.4994 | **5,722x быстрее**     |
| 1,000   | **Queue**  |    27,997 | —                      |
|         | NaiveQueue |    0.4989 | **56,115x быстрее**    |
| 10,000  | **Queue**  |   291,794 | —                      |
|         | NaiveQueue |    0.4990 | **584,758x быстрее**   |
| 100,000 | **Queue**  | 3,561,192 | —                      |
|         | NaiveQueue |    0.5022 | **7,092,781x быстрее** |

> **Вывод:** Peek у Queue в данной реализации имеет линейную зависимость от размера очереди.
> Это связано с тем, что при пустом front требуется построение нового front из rear, и результат нормализации
> не фиксируется в состоянии очереди. Для персистентной структуры это корректное поведение, но оно делает Peek
> операцией, ориентированной на функциональную чистоту, а не на минимальную асимптотическую стоимость. NaiveQueue
> выигрывает за счёт прямого доступа к голове.

---

## Version Creation — создание множества версий

| Размер | Версий | Реализация |   ns/op |      B/op | allocs/op | Сравнение с Queue  |
|--------|--------|------------|--------:|----------:|----------:|:-------------------|
| 1,000  | 10     | **Queue**  |   314.3 |       560 |        30 | —                  |
|        |        | NaiveQueue |   8,441 |    82,162 |        20 | **27x медленнее**  |
| 1,000  | 100    | **Queue**  |   3,049 |     5,600 |       300 | —                  |
|        |        | NaiveQueue |  83,860 |   918,905 |       200 | **28x медленнее**  |
| 10,000 | 10     | **Queue**  |   327.1 |       560 |        30 | —                  |
|        |        | NaiveQueue |  58,655 |   819,446 |        20 | **179x медленнее** |
| 10,000 | 100    | **Queue**  |   3,280 |     5,600 |       300 | —                  |
|        |        | NaiveQueue | 565,827 | 8,194,468 |       202 | **172x медленнее** |

> **Вывод:** Queue значительно эффективнее NaiveQueue при создании большого количества версий. Благодаря структурному
> шарингу стоимость создания новых версий слабо зависит от размера очереди и растёт в основном от числа операций.
> NaiveQueue вынуждена пересоздавать значительно больший объём структуры, что приводит к кратному росту времени и
> потребления памяти.

---

## Mixed Operations — смешанные операции

| Реализация |     ns/op |      B/op | allocs/op | Сравнение        |
|------------|----------:|----------:|----------:|:-----------------|
| **Queue**  | 3,035,117 | 5,155,758 |   321,657 | —                |
| NaiveQueue |   574,066 | 5,691,753 |     2,304 | **5.3x быстрее** |

> **Вывод:** В сценарии смешанных операций NaiveQueue оказывается быстрее по времени выполнения и создаёт существенно
> меньше аллокаций. Это объясняется тем, что Queue в рамках персистентной модели активно создаёт новые промежуточные
> структуры и версии, тогда как NaiveQueue реализует операции с меньшим количеством структурных преобразований.

---

## Memory Allocation — аллокации при Dequeue

| Реализация |  ns/op | B/op | allocs/op | Сравнение        |
|------------|-------:|-----:|----------:|:-----------------|
| **Queue**  | 0.9915 |    0 |         0 | —                |
| NaiveQueue | 0.2836 |    0 |         0 | **3.5x быстрее** |

> **Вывод:** Dequeue у обеих персистентных реализаций не приводит к дополнительным аллокациям памяти. Queue проигрывает
> NaiveQueue по абсолютному времени из-за дополнительной логики поддержки двух стеков,
> однако обе реализации демонстрируют предсказуемое и стабильное поведение без роста накладных расходов.